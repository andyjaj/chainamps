<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>ChainAMPS: ChainAMPS manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChainAMPS
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Code for working with chain array matrix product states.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ChainAMPS manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sIntro">Introduction</a></li>
<li class="level1"><a href="#sBasic">Basic Elements</a><ul><li class="level2"><a href="#sVertex">The Vertex Class</a></li>
<li class="level2"><a href="#sState">The State Class</a></li>
<li class="level2"><a href="#sMPX_matrix">The MPX_matrix (and MPO_matrix, MPS_matrix) Class</a></li>
</ul>
</li>
<li class="level1"><a href="#sDrivers">The Driver Routines</a><ul><li class="level2"><a href="#ssiDMRGguide">The iDMRG driver</a><ul><li class="level3"><a href="#sssiDMRG">The iDMRG class</a></li>
<li class="level3"><a href="#sssiDMRGOutput">iDMRG Output</a></li>
</ul>
</li>
<li class="level2"><a href="#ssfDMRGguide">The Finite DMRG driver</a><ul><li class="level3"><a href="#sssfDMRGOutput">fDMRG Output</a></li>
</ul>
</li>
<li class="level2"><a href="#ssiTEBDguide">The iTEBD driver</a><ul><li class="level3"><a href="#sssiTEBDOutput">iTEBD Output</a></li>
</ul>
</li>
<li class="level2"><a href="#ssTEBDguide">The TEBD driver</a><ul><li class="level3"><a href="#sssTEBDOutput">TEBD Output</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#sTechnical">Technical Details</a></li>
</ul>
</div>
<div class="textblock"><p>Libraries and driver routines for Matrix product state (MPS) algorithms with large local (physical) dimension. Intended to be used for studying models of (infinitely) many coupled chains.</p>
<h1><a class="anchor" id="sIntro"></a>
Introduction</h1>
<p>Most physically interesting many-body states have limited (in some sense) entanglement. Matrix product states constitute a variational basis with entanglement restricted by the matrix or <em>bond</em> dimension. Key to their usefulness is that (at least in 1D) they can searched through in a numerically efficient manner, so that it is possible to design powerful MPS algorithms that can accurately study many-body problems. </p>
<h1><a class="anchor" id="sBasic"></a>
Basic Elements</h1>
<p>We first describe some of the fundamental objects used in code. Almost everything (barring some of the low lying sparse and dense matrix operations) is defined within the namespace 'ajaj'. </p>
<h2><a class="anchor" id="sVertex"></a>
The Vertex Class</h2>
<p>A matrix product state is formed, unsurprisingly, from products of matrices, \( A^{\sigma_{i+1}}_{a_i,a_{i+1}}\), where the \(a\)'s are matrix indices and \( \sigma\) is a label for a state in some local (usually called <em>physical</em>) Hilbert space. For a system of \(N\) objects, each with a local Hilbert space labelled by \( \sigma_i\), we have:</p>
<p>\( \left\vert \psi_{\text MPS}\right\rangle = \sum_{\{\sigma\}} \text{Tr}\, A^{\sigma_1} A^{\sigma_2} \cdots A^{\sigma_N} \left\vert \sigma_1 \right\rangle\cdots\left\vert \sigma_N \right\rangle. \)</p>
<p>In normal MPS usage each local object is a single site in some lattice. Instead we refer to the local object as a <em>vertex</em>. This is because the local object could itself be a chain (either a lattice or continuum version). The vertex Hilbert space, and the matrix elements for any necessary operators are set by the builtin models in the vertex_generators subdirectory, or by a user defined set of files.</p>
<p>The Vertex class (<a class="el" href="vertex_8hpp.html" title="A model is a combination of the vertex definition (e.g. ">vertex.hpp</a>) is then essentially some parameters (for the local Hamiltonian), a spectrum (a list of eignestates of the local Hamiltonian) and a list of matrices (the local operators). In order to create an instance of Vertex, one needs to provide some parameters and then call a Vertex constructor. Currently the builtin examples provide an easy way to do this. </p>
<h2><a class="anchor" id="sState"></a>
The State Class</h2>
<p>In general the code uses good quantum numbers to increase numerical efficiency. These need to be good local quantum numbers (i.e. states in the local/physical spectrum cannot mix them).</p>
<p>The quantum numbers are conserved charges for various \(\mathbb{Z}_n\) symmetries, including th 'infinite' case \(\mathbb{Z}\). A State object (<a class="el" href="states_8hpp.html" title="Defines State and EigenState. ">states.hpp</a>) holds a list of 'charge rules' which give the values of \(n\) for each quantum number. If \(n\le 0\) then \( \mathbb{Z} \) is assumed. The State also holds a list of the actual values of its particular charges, which are in the range \( 0,\cdots,n-1\), excepting the \( \mathbb{Z} \) case for which negative values are allowed.</p>
<p>These State objects can be added in order to calculate the charges of their tensor product. Modulo arithmetic is taken care of internally so that resulting charges are in the range \( 0,\cdots,n-1\). They can also be subtracted, which is useful for directed matrix indices, or when a quotient of some sort is needed. An EigenState object is a State of the vertex Hamiltonian, with an attached value of its energy under the action of the aforementioned operator. Because charges are expected to be relatively small they are stored as 'QuantumNumberInt' type, which is a typedef for 'short int'.</p>
<p>It is often useful to have an 'Identity' State which doesn't change another State when added to or subtracted from it (basically all charges=0). This can be constructed via </p><div class="fragment"><div class="line"><a class="code" href="classajaj_1_1_state.html">ajaj::State</a>(myvertex.ChargeRules) </div>
</div><!-- fragment --><p> because any State constructed from charge rules alone has zero for all charge values by default. To construct a more elaborate State (e.g. as a target sector for DMRG): </p><div class="fragment"><div class="line"><a class="code" href="namespaceajaj.html#a87639289dc139a338ac94c1129ad8770">ajaj::QNVector</a> somecharges; <span class="comment">//create a vector of type QNVector (holds several QuantumNumberInt&#39;s)</span></div>
<div class="line">somecharges.push_back(0); <span class="comment">//Sets Sz=0 for xxx, sets momentum=0 for Ising etc.</span></div>
<div class="line">somecharges.push_back(0); <span class="comment">//Sets crystal momentum=0 for xxx, sets sector for Ising</span></div>
<div class="line"><a class="code" href="classajaj_1_1_state.html">ajaj::State</a> TargetState(myvertex.ChargeRules,somecharges); <span class="comment">//create State called &#39;TargetState&#39;, assuming myvertex has already been provided</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="sMPX_matrix"></a>
The MPX_matrix (and MPO_matrix, MPS_matrix) Class</h2>
<p>This class implements the underlying tensor. MPO_matrix and MPS_matrix are inherited types that check for the correct number and type of indices after construction. The class holds a sparse matrix to store the actual data, and a list of tensor indices. It also contains member functions for various operations, such as eigenvalue decompositions and singular value decompositions.</p>
<p>Currently all tensors need a reference to the physical spectrum, even if none of their indices are physical. This is quite likely an unnecessary design limitation.</p>
<p>The tensor indices are of type 'MPXIndex' which is essentially a list of State objects and a <em>direction</em>, ingoing or outgoing, for charge conservation purposes. Each MPXIndex also has a flag which indicates whether it is a 'physical' or 'matrix' index.</p>
<p>As the underlying data is stored as a matrix the tensor indices have to be collected together to form row and column indices. The first m_NumRowIndices in the list are collected together to form a matrix row index, while the remainder form the column index.</p>
<p>MPX_matrix types can be transformed by transpose, conjugation using member functions, and can be contracted to form another MPX_matrix, or just to a SparseMatrix object. See <a class="el" href="_m_p_x_8hpp.html" title="MPX_matrix is the base class for MPS and MPO matrices. ">MPX.hpp</a> for more details. </p>
<h1><a class="anchor" id="sDrivers"></a>
The Driver Routines</h1>
<p>The basic first step in all drivers is the creation of a vertex, then the creation of a Hamiltonian MPO_matrix (using a function defined in the same file): The drivers then fall into two classes: eigenstate solvers and time evolution algorithms, which are further subdivided into versions for infinite and finite numbers of vertices. </p>
<h2><a class="anchor" id="ssiDMRGguide"></a>
The iDMRG driver</h2>
<p>iDMRG is implemented via the driver <a class="el" href="i_d_m_r_g___d_r_v_8cpp.html" title="Driver file for iDMRG. ">iDMRG_DRV.cpp</a>. After creating a vertex object and Hamiltonian MPO, a target state is declared. This defines the sector in which we look for a lowest energy state, by the values of its charges. We also need an output file object, using the methods in <a class="el" href="data_8hpp.html" title="structure for outputting data to file ">data.hpp</a>: </p><div class="fragment"><div class="line"><a class="code" href="classajaj_1_1_data_output.html">ajaj::DataOutput</a> results(<span class="stringliteral">&quot;Energies.dat&quot;</span>); <span class="comment">//create a handler for a data file.</span></div>
</div><!-- fragment --><p> In the case of iDMRG, we store both the energies of a finite size system in 'Energies.dat' and later the energies of the orthogonal unit cell as 'iDMRGEnergies.dat'.</p>
<p>The iDMRG algorithm works by repeatedly 'inserting' two vertices at the centre of the system: essentially using an eigensolver with a good initial guess to find the correct matrices to represent these two new vertices. Initially we just do this for a few steps (without explicitly forming an orthogonal/canonical unit cell to represent an infinite system). Optionally we can specify a non zero convergence_test, which will stop the algorithm when the answer and prediction vector are close enough. </p><div class="fragment"><div class="line"><a class="code" href="classajaj_1_1i_d_m_r_g.html">ajaj::iDMRG</a> infvol(std::string(<span class="stringliteral">&quot;GroundState&quot;</span>),H,TargetState,results); <span class="comment">//create infinite algorithm DMRG object, save all blocks and matrices with name &#39;GroundState&#39;.</span></div>
<div class="line">infvol.run(steps,convergence_test,CHI,minS); <span class="comment">//Add two new vertices at the centre, &#39;steps&#39; times. </span></div>
</div><!-- fragment --><p> After the initial steps, which grow the system to 2*steps vertices, we continue to run the algorithm, but now after each step we use the new central vertices to form an orthogonal unit cell representative of the (translationally invariant) infinite limit. In order to obtain the infinite system energy, we imagine breaking up the full hamiltonian into a sum of single vertex terms, \( h_i\) and bonds \( B_{i,i+1}\). We then measure the bond energy for our unit cell, and add to it half the energy of the two on-vertex energies. This gives us the energy per vertex, <a class="el" href="namespaceajaj.html#a0acc97cda24b52fea68795a81bdcf033" title="Special routine to measure the energy per vertex, because Hamiltonian is a lower triangular matrix pr...">ajaj::SimpleEnergy()</a>. \( H=\sum_i {h_i+h_{i+1}}{2} + B_{i,i+1}\) Currently the single vertex measurement itself is somewhat inefficient, because the individual matrices in the unit cell are not canonical. Results are pushed to the file iDMRGEnergies.dat. See the code snippet below. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classajaj_1_1_m_p_x_index.html">ajaj::MPXIndex</a> dummy(1,<a class="code" href="namespaceajaj.html#a3e0386da08aa95da1271032f77664de5">ajaj::StateArray</a>(1,myvertex.Spectrum[0].getChargeRules())); <span class="comment">//create a dummy index</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classajaj_1_1_m_p_o__matrix.html">ajaj::MPO_matrix</a> H1(myvertex.Spectrum,dummy,myvertex.Spectrum.Energies()); <span class="comment">//form the on-vertex part of a Hamiltonian</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classajaj_1_1_m_p_o__matrix.html">ajaj::MPO_matrix</a> I(<a class="code" href="namespaceajaj.html#a9f6c14121c214fc4a09deb04de013354">ajaj::IdentityMPO_matrix</a>(myvertex.Spectrum)); <span class="comment">//form an identity MPO. Useful for some measurements</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classajaj_1_1_m_p_o__matrix.html">ajaj::MPO_matrix</a> LeftH(<a class="code" href="namespaceajaj.html#af064198e9aa75d4e24e5cc5a22634a21">LeftOpenBCHamiltonian</a>(H)); <span class="comment">//form the left end of the bond MPO</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classajaj_1_1_m_p_o__matrix.html">ajaj::MPO_matrix</a> RightH(<a class="code" href="namespaceajaj.html#a503eaf6932b7ca83dba14e9aac39c95a">RightOpenBCHamiltonian</a>(H)); <span class="comment">//form the right end of the bond MPO</span></div>
<div class="line">std::vector&lt;double&gt; iDMRGEnergies;</div>
<div class="line"><a class="code" href="classajaj_1_1_data_output.html">ajaj::DataOutput</a> infvolresults(<span class="stringliteral">&quot;iDMRGEnergies.dat&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span> (ajaj::uMPXInt r=0;r&lt;orthogonalisation_steps;++r){</div>
<div class="line">  infvol.run(1,-0.0,CHI,minS);</div>
<div class="line">  <a class="code" href="classajaj_1_1_unit_cell.html">ajaj::UnitCell</a> Ortho(OrthogonaliseInversionSymmetric(infvol.getCentralDecomposition(),infvol.getPreviousLambda()));</div>
<div class="line">  iDMRGEnergies.push_back(real(<a class="code" href="namespaceajaj.html#a0acc97cda24b52fea68795a81bdcf033">ajaj::SimpleEnergy</a>(LeftH,RightH,H1,I,Ortho)));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;iDMRG energy per vertex &quot;</span> &lt;&lt; iDMRGEnergies.back() &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="structajaj_1_1_data.html">ajaj::Data</a> inf_data(iDMRGEnergies.back());</div>
<div class="line">  infvolresults.push(inf_data);</div>
<div class="line">}</div>
</div><!-- fragment --> <h3><a class="anchor" id="sssiDMRG"></a>
The iDMRG class</h3>
<p>The actual objects and routines that implement DMRG are declared in <a class="el" href="_d_m_r_g__routines_8hpp.html" title="Driver functions for DMRG Currently only two site DMRG is implemented. ">DMRG_routines.hpp</a>. The <a class="el" href="classajaj_1_1i_d_m_r_g.html">ajaj::iDMRG</a> object inherits from the <a class="el" href="classajaj_1_1_super_block.html" title="Holds a superblock and can grow it or sweep it using DMRG methods. ">ajaj::SuperBlock</a> object, which itself inherits from the <a class="el" href="classajaj_1_1_blocks_structure.html" title="A container of sorts, that stores blocks and provides interface to retrieve them. ...">ajaj::BlocksStructure</a> object. The latter is basically storage for left and right blocks. Only the current left and right blocks are kept in memory, earlier blocks are saved to disk, but can be retrieved using the BlockStructure interface. A SuperBlock has all the features of a BlocksStructure but also contains the current central decomposition (two MPS matrices and a list of singular values, ajaj::CentralDecomposition) as well as the singular values from the previous growth step. Finally the iDMRG object has the properties of a SuperBlock with an added member function that initialises it, and performs the growth steps and outputs data (the fidelity and the entanglement), <a class="el" href="classajaj_1_1i_d_m_r_g.html#a296fffa158116af6829419907b90e77b" title="Perform infinite algorithm growth steps. ">ajaj::iDMRG.run()</a>.</p>
<p>Schematically the infinite volume algorithm proceeds in the following way:</p><ol type="1">
<li>For the initial step<ol type="a">
<li>Using the information in the hamiltonian MPO matrix, form left and right boundary condition hamiltonians, and from these form a two vertex hamiltonian.</li>
<li>Solve the hamiltonian using ARPACK, targeting a particular set of quantum numbers, to find \(\Psi_{\sigma_1 \sigma_2}\) and the energy.</li>
<li>Perform an SVD on the answer to get \( A^{\sigma_1} \Lambda B^{\sigma_2}\), with possible truncation. Calculate entanglement and output (with energy) to data file.</li>
<li>Using the hamiltonians for the left and right ends form the initial left and right blocks, e.g. \( A^{\sigma_1 \dagger} H_{\text{Left}} A^{\sigma_1} = L_{a&#39;_1 b_1 a_1}\).</li>
<li>Store MPS matrices and blocks.</li>
</ol>
</li>
<li>For a normal step<ol type="a">
<li>Unless already provided by the initialisation, form new left and right blocks.</li>
<li>Feed an initial guess tensor, if possible, (wavefunction prediction, requires singular values from previous two steps, see <a class="el" href="namespaceajaj.html#a399f5cd34e85dd663c52058410847be4" title="Makes a prediction vector for the eigensolver. ">ajaj::MakePrediction()</a>) to ARPACK to find the lowest eigenvalue and eigenvector, in the correct subspace, by iteratively contracting with the left and right blocks and two copies (two vertex DMRG) of the hamiltoniain MPO matrix.</li>
<li>Perform SVD with possible truncation, and output entanglement and energy.</li>
<li>Store new MPS A and B matrices and record singular values (and previous singular values).</li>
<li>If orthogonalisation (translationally invariant unit cell) is required then additionally, orthogonalise the two matrix combination, measure observables (see <a class="el" href="measurement_8hpp.html" title="Routines for measuring expectation values, and orthogonalising infinite states. ">measurement.hpp</a>) and output (with possibly new entanglement).</li>
<li>Repeat. </li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="sssiDMRGOutput"></a>
iDMRG Output</h3>
<p>The infinite volume algorithm data is output in the file Energies.dat.</p>
<p>The columns are: DMRG step, energy/number of vertices (chains), entanglement entropy, truncation error (can be inaccurate (negative) when tiny or when no truncation occurs), fidelity between previous centre and current guess.</p>
<p>The orthogonalisation and formation of a translationally invariant unit cell only occurs for later steps (exactly when is controlled by params.hpp). Once this happens the data for the orthogonalised translationally invariant unit cell is output in iDMRGEnergies.dat.</p>
<p>The columns are: orthogonalisation step, energy per vertex.</p>
<p>The one vertex (chain) density matrix is output in the file GroundState_One_Vertex_Densities.dat.</p>
<p>The first row lists the single vertex energies in order (i.e. the energies in the vertex spectrum) The next rows list the diagonal of the one vertex density matrix in the same order, for each DMRG step.</p>
<p>Currently no other operators are measured, but this won't be difficult to implement and can be done at the end once a well converged state is obtained. </p>
<h2><a class="anchor" id="ssfDMRGguide"></a>
The Finite DMRG driver</h2>
<p>DMRG for a finite number of vertcies is implemented via the driver <a class="el" href="f_d_m_r_g___d_r_v_8cpp.html" title="Driver file for finite size DMRG. ">fDMRG_DRV.cpp</a>. </p>
<h3><a class="anchor" id="sssfDMRGOutput"></a>
fDMRG Output</h3>
<h2><a class="anchor" id="ssiTEBDguide"></a>
The iTEBD driver</h2>
<p>iTEBD is implemented via the driver <a class="el" href="i_t_e_b_d___d_r_v_8cpp.html" title="Driver file for iTEBD. ">iTEBD_DRV.cpp</a>. </p>
<h3><a class="anchor" id="sssiTEBDOutput"></a>
iTEBD Output</h3>
<p>Output is in the file Evoliution.dat.</p>
<p>The columns are: measurement step, time, truncation, entropy, abs(overlap), real(overlap), imag(overlap), real(measured op 1), imag(measured op 1), etc.</p>
<p>The measured operators are currently defined in the <a class="el" href="i_t_e_b_d___d_r_v_8cpp.html" title="Driver file for iTEBD. ">iTEBD_DRV.cpp</a> file, by creating a vector of MPO's using info from the vertex definition. A better interface is needed.</p>
<p>The one vertex density matrix diagonal for each step is recorded in the same way as for iDMRG, (i.e. first row lists energies of one vertex Hamiltonian) in the file iTEBD_One_Vertex_Densities.dat. </p>
<h2><a class="anchor" id="ssTEBDguide"></a>
The TEBD driver</h2>
<p>TEBD (strictly speaking tMPS with SVD compression) for a finite number of vertices is implemented via the driver <a class="el" href="_t_e_b_d___d_r_v_8cpp.html" title="Driver file for TEBD. ">TEBD_DRV.cpp</a>. </p>
<h3><a class="anchor" id="sssTEBDOutput"></a>
TEBD Output</h3>
<h1><a class="anchor" id="sTechnical"></a>
Technical Details</h1>
<p>Some parts of the code have their own namespace because they are interfaces to other libraries. These are described below. Unsigned 64bit integers would be preferred throughout, but the underlying sparse library uses signed integers, when it doesn't always need to, for example for array indices.</p>
<p>Low level dense matrix operations are performed using lapack and blas routines. The dense storage interface is declared in <a class="el" href="dense__interface_8hpp_source.html">dense_interface.hpp</a>, while the blas/lapack routines are accessed via the interface in <a class="el" href="dense__matrix__functions_8hpp_source.html">dense_matrix_functions.hpp</a>.</p>
<p>Basic sparse operations are provided by linking to the cxsparse library from the SuiteSparse collection by Tim Davis. The wrapper interface is in <a class="el" href="sparse__interface_8hpp_source.html">sparse_interface.hpp</a>.</p>
<p>In general any complete eigenvalue or singular value decompositions on sparse objects are performed by using good quantum numbers to first form smaller dense block matrices, then using dense routines from lapack and blas. This removes the need to permanently store dense blocks. However when only a few eigenvalues of a large sparse are needed (as in the DMRG eigensolver step or orthogonalisation of a unit cell) ARPACK is used. The interface to ARPACK is in <a class="el" href="arpack__interface_8hpp.html" title="Interface to arpack fortran calls Can do sparse and dense eigensolving for a few eigenvalues and vect...">arpack_interface.hpp</a>. <b>ARPACK remains temperamental, depending on the version, and can sometimes return poorly converged or incorrectly ordered eigenvalues.</b> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
